<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yoga Sutra Trees</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/interactjs/dist/interact.min.js"></script>


    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <!-- Include Cytoscape.js -->
      <!-- Include Cytoscape.js context-menu extension -->
    <script src="https://unpkg.com/cytoscape-context-menus/cytoscape-context-menus.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-beta.1/dist/js/select2.min.js"></script>
    
    <script src="http://cytoscape.github.io/cytoscape.js/api/cytoscape.js-latest/cytoscape.min.js"></script>
     <script src="https://cdn.jsdelivr.net/npm/cytoscape-node-html-label@1.1.3/dist/cytoscape-node-html-label.min.js"></script>
  
    
    
</head>
<style>
    body {
        transition: background-color 1.5s ease;
    }
    #cy {
        width: 1200px;
        height: 700px;
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
    }
    
  .resizable-section {
    overflow-y: auto; /* Enable vertical scrollbar if content overflows */

  }

    #details-content {
            overflow: auto;
            max-height: 400px; /* Set the maximum height */
            width: 100%;
        }    
    .hide {
            display: none !important;
    }    
    @media screen and (max-aspect-ratio: 1/1) {
    body {
        transform: rotate(-90deg);
        transform-origin: left top;
        width: 100vh;
        height: 100vw;
        overflow-x: hidden;
        position: absolute;
        top: 100%;
        left: 0;
    }
    }
    
    @media (max-width: 768px) {
    #wonderHeader {
      height: 6vh; /* Adjust the height for tablets and mobile devices */
    }
   }

    #leftSidebar {
        backdrop-filter: blur(3px);
    }    
    #sidebar {
        backdrop-filter: blur(3px);
    }
  
  
</style>

<body>

  <div id="cy"></div>

  <div id="sidebar" class="fixed right-0 bottom-0  w-64 overflow-auto p-4 flex flex-col items-center justify-center transition-transform transform duration-500 ease-in-out border-t border-gray-600" style="height: 90%;  transform: translateX(100%); background-color: rgba(240, 241, 242, 0.8); ">
    <h2 class="text-xl font-bold mb-4 text-grey-500">Options</h2>
    <button id="add-link-btn" class="hover:text-indigo-600 active:text-violet-700 text-white w-full font-bold py-1 px-4 rounded mb-2" style="background-color: #248e95;">Add Edge</button>
    <button id="remove-link-btn" class="hover:text-indigo-600 active:text-violet-700 text-white w-full font-bold py-1 px-4 rounded mb-2" style="background-color: #248e95;" >Remove edge</button>
    <div style="display: flex; justify-content: space-between;">
        <input type="color" id="color-picker-nodes" value="#FFFFB9">
        <input type="color" id="color-picker-border" value="#A2E1E4">
        <input type="color" id="color-picker-edges" value="#C6E0EA">
        <input type="color" id="color-picker-highlight" value="#F98645">
    </div>
    <div class="mt-2 w-full">
        <h2 class="text-base text-center text-gray-600">Display Select</h2>
        <select id="displaySelector" class="block w-full py-4 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" multiple="multiple"></select>  
        <h2 class="text-base text-center text-gray-600">Node Select</h2>
        <select id="attributeSelector" class=" block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" multiple="multiple"></select>  
        <select id="tagSelect" class="mt-1 mb-20 block w-full py-2 px-3 border border-gray-300 bg-transparent rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" multiple="multiple"></select>  
    </div>
    <div class="flex justify-between">
        <input type="text" id="node-id-input" placeholder="Search Aphorism" class="mt-5 flex-grow bg-transparent text-center">
    </div>
  </div>





  <div id="leftSidebar" class="fixed left-0 bottom-0 w-96 resize-x overflow-auto p-4 flex flex-col items-center justify-center transition-transform transform duration-500 ease-in-out border-t border-gray-600" style="height: 90%; transform: translateX(-100%); background-color: rgba(235, 236, 237, 0.83);">
    <input type="color" id="color-picker-specificnode" value="#FFFFB9" style="position: absolute; top: 10px; right: 10px;">
    
    
<p id="titleSection" ondblclick="makeTitleEditable(this)" class="w-full" style="text-align: center;"></p>    
            
    
<div id="details-content" class="w-full p-4 text-justify"></div>

<div id="editable-content" class="w-full p-2 border-t border-gray-700 m-2 p-2 resizable-section" style="display: flex; flex-direction: column;">

  <p id="tagsSection" ondblclick="makeTagsEditable(this)" class="w-full border-t border-b border-gray-700 m-2 p-4 resizable-section">
    <strong>Click on a node to start.</strong> Once started, those three fields are editable with double click and resizable with dragging. The title of the Sutra can also be edited with double click. Insert the tags as comma separated.
    
  </p>

  <p id="referencesSection" ondblclick="makeReferencesEditable(this)" class="w-full p-4 border-b border-t m-2 p-2 border-gray-700 resizable-section">
    You can also resize the panel touching the right side. You can change the node color using the color picked in the right corner. You can change the color of the graph (background, border, edge, selected) using the right color pickers.
  </p>

  <p id="commentsSection" ondblclick="makeCommentsEditable(this)" class="w-full p-4 border-b border-t m-2 border-gray-700 resizable-section">
    You can use the right panel to select the content shown for a node, both in the display and in the panel.
  </p>
    </div>
</div>


  <div id="myDiv" style="background-image: url('bg8.jpg'); background-repeat: no-repeat; background-size: cover; background-attachment: fixed; height: 1000px;">
    <div>
        <header id="wonderHeader" class="fixed w-full bg-white bg-opacity-75 top-0" style="height: 10vh;">
            <div id="divideLine" class="absolute inset-x-1/4 bottom-0 h-px bg-gray-700"></div>
            <nav class="flex items-center justify-between p-6 lg:px-8" aria-label="Global">
                <div class="flex lg:flex-1 justify-start">
                    <a href="https://github.com/Giacomo-De-Luca/YogaSutraTrees/tree/main" target="_blank" class="shadow-xl">
                        <img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Logo" width="30" height="30" class="shadow-xl">
                    </a>
                </div>
                <div id="titles" class="flex sm:gap-x-4 md:gap-x-6 lg:gap-x-12 justify-around items-center">
                    <a href="https://project-patanjali.gitbook.io/yoga-sutra-trees/" class="text-sm font-semibold leading-6 text-gray-900 hover:text-indigo-600 active:text-violet-700 ">About</a>
                    <button id="saveButton" class="text-sm font-semibold leading-6 text-gray-900 hover:text-indigo-600 active:bg-violet-700 ">Save</button>
                    <button id="load-btn" class="text-sm font-semibold leading-6 text-gray-900 hover:text-indigo-600 active:bg-violet-700 ">Load</button>
                    <input type="file" id="file-input" accept=".json" style="display: none;">             
                    <input type="text" id="nodeSearch" placeholder="Search" class="text-sm bg-transparent  font-semibold text-left" style="width: 55px;">
                </div>
                <div class="flex lg:flex-1 justify-end relative">
                    <button id="sidebarToggle" class="ml-auto z-100 hover:text-indigo-600">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-6 w-6">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                        </svg>
                    </button>
                </div>
            </nav>
        </header>
    </div>



    <div class="flex items-center justify-center min-h-screen">
        <div id="textContainer" class="mx-auto max-w-2xl p-20 bg-white bg-opacity-80 rounded-md">
        <!-- Your existing text content -->
        <div class="text-center">
            <h1 class="text-4xl font-bold tracking-tight text-black sm:text-6xl">Yoga Sutra Trees</h1>
            <p class="mt-6 text-lg leading-8 text-gray-800">A Graph visualization project to explore Patanjali's
                Aphorisms</p>
            <div class="mt-10 flex items-center justify-center gap-x-6">
                <a href="#" onclick="toggleContent()"
                    class="rounded-md bg-indigo-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600">Get
                    started</a>
                <a href="https://project-patanjali.gitbook.io/yoga-sutra-trees/" class="text-sm font-semibold leading-6 text-gray-900 hover:text-indigo-500">Documentation <span>â†’</span></a>
            </div>
        </div>
    </div>
    </div>
</div>
    
    <script>



        document.addEventListener('DOMContentLoaded', function () {
            let cy = null; // Define cy here
            // Load your JSON data (replace 'your-graph.json' with your actual file path)
            
            
             // Debugging: Print files in the folder
              fetch('./') // Change './' to the appropriate path if needed
                  .then(response => response.text())
                  .then(files => console.log('Files in the folder:', files));
                      
            fetch('graph.json')
                .then(response => response.json()) 
                
                .then(data => {
                    // Initialize Cytoscape
                     cy = cytoscape({
                        container: document.getElementById('cy'),
                        elements: data.elements,
                        userPanningEnabled: true,
                        autoungrabify: false,
    
                        minZoom: 0.1, // the furthest you can zoom out
                        maxZoom: 3, // the furthest you can zoom 

                        
    
    
                        style: [
                            {
                                selector: 'node',
                                style: {
    
                                    'label': 'data(id)',
                                    'width': 'label', // Set the width based on the label content
                                    'height': 'label', // Set the height based on the label content
                                    'shape': 'roundrectangle',
                                    'background-color': '#FFFFB9', // Set background color to white
                                    'border-width': 2,                                
                                    'text-wrap': 'wrap',
                                    'text-max-width': 220,
                                    'text-valign': 'center',
                                    'text-halign': 'center',
                                    'color': '#000',
                                    'padding-top': '15px',
                                    'font-family': 'Palatino, Palatino Linotype, serif', // Add this line for font-family
                                    'font-size': 12,
                                    'font-weight': '500',
                                    'border-color': '#5cbcc4', // Set your desired border color
                                    'padding-bottom': '10px', // Add padding to the bottom
                                    
                                }
                            },
                            {
                              selector: 'node[title]', // Only apply to nodes that have the 'title' attribute
                              style: {
                               'text-margin-y': '10px',
                               'padding-bottom': '18px',
                                  
                              }
                          },
                            {
                                selector: 'edge',
                                style: {
                                    'curve-style': 'bezier',
                                    
                                    'target-arrow-shape': 'none',
                                    'width': 5,
                                    'line-color': '#73BDC9',
                                    'target-arrow-color': '#ccc'
                                    
                                }
                            },
                            {
                                selector: 'edge[edgeType = "type2"]',
                                style: {
  
                                    
                                    'curve-style': 'unbundled-bezier',
                                    'control-point-distance': 50, // Adjust this value as needed
                                    'control-point-weight': 0.5,
                                    'control-point-step-size': 40,
                                    'target-arrow-shape': 'none',
                                    'width': 5,
                                    'line-color': '#8BCCE6', // Change this to the color you want for the new type of edge
                                    'target-arrow-color': '#ccc'
                                }
                            },                    
                            {
                                selector: '.blurred',
                                style: {
                                    'opacity': 0.5
                                }
                            },
                            {
                                selector: '.highlighted',
                                style: {
                                    'background-color': '#E0CD9F'
                                }
                            },
                            {
                                selector: '.spotted',
                                style: {
                                    'background-color': '#D29165'
                                }
                            }
                            
                           
                        ],
                        
                                    
              
                 
                                                
                        
                        
                        
                        layout: { 
                            name: 'preset',
                            positions: node => data.positions[node.data('id')]
                        }, // You can use a different layout if needed
                        ready: function() {
                            this.fit(); // Fit the viewport to the graph
                        }
                    });
                    
                    
                    
                            
                                    
                             
       
                
    
                    document.getElementById('saveButton').addEventListener('click', function () {
                        // Get the current nodes and edges
                        var nodes = cy.nodes().map(node => ({ data: node.data() }));
                        var edges = cy.edges().map(edge => ({ data: edge.data() }));
                    
                        // Get the current positions
                        var positions = {};
                        cy.nodes().forEach(node => {
                            positions[node.data('id')] = node.position();
                        });
                    
                        // Create a new JSON object
                        var json = {
                            elements: {
                                nodes: nodes,
                                edges: edges
                            },
                            positions: positions
                        };
                    
                        // Convert the JSON object to a string
                        var jsonString = JSON.stringify(json, null, 2);
                    
                        // Create a new Blob object from the JSON string
                        var blob = new Blob([jsonString], { type: 'application/json' });
                    
                        // Create a new object URL for the Blob object
                        var url = URL.createObjectURL(blob);
                    
                        // Create a new link element
                        var link = document.createElement('a');
                    
                        // Set the href of the link to the object URL
                        link.href = url;
                    
                        // Set the download attribute of the link to the desired file name
                        link.download = 'graph.json';
                    
                        // Append the link to the body
                        document.body.appendChild(link);
                    
                        // Simulate a click on the link
                        link.click();
                    
                        // Remove the link from the body
                        document.body.removeChild(link);
                    });

         function handleNodeTap(callback) {
             let sourceNode = null;
             let targetNode = null;
             
             function onTap(event) {
                 if (sourceNode === null) {
            sourceNode = event.target;
        } else {
            targetNode = event.target;
            if (sourceNode.id() !== targetNode.id()) {
                callback(sourceNode, targetNode);
            }
            sourceNode = null;
            targetNode = null;
            cy.nodes().off('tap', onTap);
        }
    }

    cy.nodes().on('tap', onTap);
}

// Event listener for the "Add Link" button
document.getElementById('add-link-btn').addEventListener('click', function () {
    handleNodeTap((sourceNode, targetNode) => {
        cy.add({ data: { source: sourceNode.id(), target: targetNode.id() } });
    });
});

// Event listener for the "Remove Link" button
document.getElementById('remove-link-btn').addEventListener('click', function () {
    handleNodeTap((sourceNode, targetNode) => {
        var edges = cy.edges().filter(edge => {
            return (edge.source().id() === sourceNode.id() && edge.target().id() === targetNode.id()) ||
            (edge.source().id() === targetNode.id() && edge.target().id() === sourceNode.id());
        });
        if (edges.length > 0) {
            edges.remove();
        }
    });
});

                let detailsContent = "";


                
                function openLeftSidebar(node) {
                    const nodeId = node.id();
                    var leftSidebar = document.getElementById('leftSidebar');
                    leftSidebar.style.transform = "translateX(0)";
                    leftSidebar.style.boxShadow = "1px 0px 3px 0px rgba(0,0,0,0.3)"; 

                    // Check if displaySelector is initialized and has selected options
                    if ($.fn.select2 && $('#displaySelector').data('select2')) {
                        // Get the selected attributes
                        const selectedAttributes = $('#displaySelector').select2('data').map(option => option.id);
                        
                        // Build the additional details content using the selected attributes
                        selectedAttributes.forEach(attribute => {
                            if (node.data(attribute)) {
                                detailsContent += `<p><strong>${attribute}:</strong> ${node.data(attribute)}</p>`;
                            }
                        });
                    };
                    

                        // Display comments in the comments section
                        const commentsSection = document.getElementById('commentsSection');
                        commentsSection.innerHTML = `<strong>Comments:</strong> ${node.data('comment') || ''}`;
                        
                        
                        // Display title in the title section
                        const titleSection = document.getElementById('titleSection');
                        titleSection.innerHTML = `${node.data('title') || 'Title'}`;
                        
                        
                        // Display tags in the tags section
                        const tagsSection = document.getElementById('tagsSection');
                        tagsSection.innerHTML = `<strong>Tags:</strong> ${node.data('tags') || ''}`;
                        
                        // Display references in the references section
                        const referencesSection = document.getElementById('referencesSection');
                        referencesSection.innerHTML = `<strong>References:</strong> ${node.data('references') || ''}`;

                        currentOpenNodeId = nodeId;

                        commentsSection.addEventListener('dblclick', function () {
                            makeCommentsEditable(commentsSection);
                        });
                        
                        titleSection.addEventListener('dblclick', function () {
                            makeTitleEditable(titleSection);
                        });
                    
                        tagsSection.addEventListener('dblclick', function () {
                            makeTagsEditable(tagsSection);
                        });

                        referencesSection.addEventListener('dblclick', function () {
                            makeReferencesEditable(referencesSection);
                        });
                    }

                const searchInput = document.getElementById('nodeSearch');
                const matchCountDisplay = document.getElementById('matchCount');
                
                searchInput.addEventListener('input', function() {
                    const searchText = searchInput.value.trim().toLowerCase();
                    let matchCount = 0;
                
                    // First, remove all temporary edges
                    cy.edges('.temporary-text').remove();
                
                    // If the search text is empty, remove the 'highlighted' and 'blurred' classes from all nodes and return
                    if (searchText === '') {
                        cy.nodes().removeClass('highlighted blurred');
                        return;
                    }
                
                    // Get the nodes that match the search text
                    const matchedNodes = cy.nodes().filter(node => {
                        const nodeId = node.data('id').toLowerCase();
                        const nodeLabel = node.data('Sanskrit_Text').toLowerCase();
                        const translationBryant = node.data('Translation_Bryant').toLowerCase();
                
                        // Check if any of the fields contains the search text
                        if (nodeId.includes(searchText) || nodeLabel.includes(searchText) || translationBryant.includes(searchText)) {
                            // Add the 'highlighted' class and remove the 'blurred' class
                            node.addClass('highlighted');
                            node.removeClass('blurred');
                            matchCount++;
                            return true;
                        } else {
                            // Add the 'blurred' class and remove the 'highlighted' class
                            node.addClass('blurred');
                            node.removeClass('highlighted');
                            return false;
                        }
                    });
                
                    // Create temporary edges between the matched nodes
                    matchedNodes.forEach(function (node, index) {
                        for (let i = index + 1; i < matchedNodes.length; i++) {
                            const otherNode = matchedNodes[i];
                            cy.add({
                                group: 'edges',
                                data: { source: node.id(), target: otherNode.id() },
                                classes: 'temporary-text',
                                style: { 'line-color': '#CFC8FA' } // Change this to the color you want
                            });
                        }
                    });
                });

                document.getElementById('load-btn').addEventListener('click', function () {
                    document.getElementById('file-input').click();
                });
                document.getElementById('file-input').addEventListener('change', function (e) {
                    var file = e.target.files[0];
                    if (!file) {
                        return;
                    }
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        var contents = e.target.result;
                        var data = JSON.parse(contents);

                        // Reconfigure the graph
                        cy.elements().remove();
                        cy.add(data.elements);
                        cy.nodes().forEach(node => {
                            node.position(data.positions[node.data('id')]);
                        });
                    };
                    reader.readAsText(file);
                });


                let select = document.getElementById('tagSelect');
                
                $(select).select2({
                    tags: true,
                    tokenSeparators: [','],
                    placeholder: 'Select tags',
                    templateResult: formatTag,
                    templateSelection: formatTag
                });
                
                // Define the formatTag function
                function formatTag(tag) {
                    var $tag = $('<span><i class="tag-color"></i> ' + tag.text + '</span>');
                    $tag.find('.tag-color').css({
                        'background-color': tagColors[tag.text] || '#000',
                        'display': 'inline-block',
                        'width': '10px',
                        'height': '10px',
                        'margin-right': '5px'
                    });
                    return $tag;
                }
                
                // Define the color palette
                const colorPalette = ['#DBD788', '#DB9B88', '#88DBC5', '#A588DB', '#839993'];
                
                
                function getRandomDesaturatedColor() {
                    // Function to generate a random desaturated color
                    const randomHue = Math.random() * 360;
                    const randomSaturation = 20 + Math.random() * 60; // Adjust the saturation range as needed
                    const randomLightness = 50 + Math.random() * 30; // Adjust the lightness range as needed

                    return `hsl(${randomHue}, ${randomSaturation}%, ${randomLightness}%)`;
                }
                
                
                function getRandomHexColor() {
                    let letters = "0123456789ABCDEF";
                    let color = '#';
                    
                    for (let i = 0; i < 6; i++) {
                        color += letters[Math.floor(Math.random() * 16)];
                    }
                    
                    return color;
                }
                                                    
                // Create a mapping from tags to colors
                
                let tagColors = {};
                let colorIndex = 0;
                cy.nodes().forEach(function (node) {
                    const nodeTags = node.data('tags') ? node.data('tags').split(', ') : [];
                    nodeTags.forEach(tag => {
                        if (!tagColors[tag]) {
                                                    if (colorIndex < 6) {
                                tagColors[tag] = colorPalette[colorIndex];
                            } else {
                                // Assign a random desaturated color for each tag


                                tagColors[tag] = getRandomHexColor()
                                
                            }
                            colorIndex++;
                        }
                    });
                });
                
                // Add event listener
                $(select).on('change', function () {
                    const selectedTags = $(this).select2('data').map(option => option.text);
                    if (selectedTags.length > 0) {
                        filterNodesByTag(selectedTags);
                    } else {

                        // Reset all nodes to their default color
                        
                        cy.edges('.temporary-tag').remove();
                        cy.nodes().removeClass('filtered highlighted blurred');
                        resetNodesToModifiedColor();
                    }
                });
                
                updateDropdownOptions();

                function filterNodesByTag(selectedTags) {
                    

                    // First, remove all temporary edges
                    cy.edges('.temporary-tag').remove();
                
                    // Reset all nodes to their default color
                    resetNodesToModifiedColor();
                
                    // If no tags are selected, remove the 'blurred' class from all nodes and return
                    if (selectedTags.length === 0) {
                        cy.nodes().removeClass('blurred');
                        return;
                    }
                
                    cy.nodes().addClass('blurred');
                
                    // Get the nodes that have at least one of the selected tags
                    const selectedNodes = cy.nodes().filter(function (node) {
                        
                        const nodeTags = node.data('tags') ? node.data('tags').split(', ') : [];
                        const nodeSelectedTags = nodeTags.filter(tag => selectedTags.includes(tag));
                        return nodeSelectedTags.length > 0;
                    });
                
                    // For each selected node
                    selectedNodes.forEach(function (node, index) {
                        const nodeTags = node.data('tags') ? node.data('tags').split(', ') : [];
                        const nodeSelectedTags = nodeTags.filter(tag => selectedTags.includes(tag));
                        const nodeSelectedColors = nodeSelectedTags.map(tag => tagColors[tag]);
                        node.style('background-color', mixColors(nodeSelectedColors));
                        node.removeClass('blurred'); // Remove the 'blurred' class
                
                        // Create temporary edges between this node and all other selected nodes
                        for (let i = index + 1; i < selectedNodes.length; i++) {
                            const otherNode = selectedNodes[i];
                            cy.add({
                                group: 'edges',
                                data: { source: node.id(), target: otherNode.id() },
                                classes: 'temporary-tag',
                                style: { 'line-color': mixColors(nodeSelectedColors) }
                            });
                        }                    
                    });
                }

                function mixColors(colors) {
                    let r = 0;
                    let g = 0;
                    let b = 0;
                
                    colors.forEach(color => {
                        r += parseInt(color.slice(1, 3), 16);
                        g += parseInt(color.slice(3, 5), 16);
                        b += parseInt(color.slice(5, 7), 16);
                    });
                
                    r = Math.floor(r / colors.length);
                    g = Math.floor(g / colors.length);
                    b = Math.floor(b / colors.length);
                
                    return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
                }
                
                // Function to handle the search action
                function handleSearch() {
                    // Remove the 'highlighted' class from all nodes
                    cy.nodes().removeClass('highlighted');
                    
                    // Get the node ID from the input field
                    var nodeId = document.getElementById('node-id-input').value;
                    // If the input field is not empty
                    if (nodeId) {
                        // Find the node in the Cytoscape graph
                        var node = cy.getElementById(nodeId);
                        // Check if the node exists
                        if (node.length > 0) {
                            // Highlight the node
                            node.addClass('highlighted');
                            // Call the openLeftSidebar function
                            updateDetailsID(nodeId)
                        } else {
                            alert('Node not found');
                        }
                    }
                }
                
                // Event listener for the Enter key on the input field
                document.getElementById('node-id-input').addEventListener('keypress', function (e) {
                    // Check if the Enter key was pressed
                    if (e.key === 'Enter') {
                        handleSearch();
                    }
                });

                const colorPickerNodes = document.getElementById('color-picker-nodes');
                const colorPickerBorder = document.getElementById('color-picker-border');
                const colorPickerEdges = document.getElementById('color-picker-edges');
                const colorPickerHighlight = document.getElementById('color-picker-highlight');



                // Change node colour background
                colorPickerNodes.addEventListener('change', function () {
                    // Get the selected color
                    const color = this.value;
                    
                    // Change the styles of the nodes
                    cy.style()
                    .selector('node')
                    .style({
                        'background-color': color,
                    })
                    .update(); // Apply the changes
                });

                   // Change colour border
                   colorPickerBorder.addEventListener('change', function () {
                    // Get the selected color
                    const color = this.value;
                    
                    // Change the styles of the nodes
                    cy.style()
                    .selector('node')
                    .style({
                        'border-color': color,
                    })
                    .update(); // Apply the changes
                });

                   // Change colour edges
                   colorPickerEdges.addEventListener('change', function () {
                    // Get the selected color
                    const color = this.value;
                    
                    // Change the styles of the edges
                    cy.style()
                    .selector('edge')
                    .style({
                        'line-color': color,
                    })
                    .update(); // Apply the changes
                });

                   // Change highlight on select
                   colorPickerHighlight.addEventListener('change', function () {
                    // Get the selected color
                    const color = this.value;
                    
                    // Change the styles of the highlight on selection
                    cy.style()
                    .selector('.spotted')
                    .style({
                        'background-color': color,
                    })
                    .update();  // Apply the changes
                });
                
                function resetNodesToModifiedColor() {
                     // Get all nodes in the graph
                      const allNodes = cy.nodes();

                      // Iterate through all nodes
                      allNodes.forEach(node => {
                        const nodeId = node.id();
                        const modifiedColor = modifiedNodeColors.get(nodeId);

                        if (modifiedColor !== undefined) {
                             // If the node has a modified color, set it
                              node.style('background-color', modifiedColor);
                            } else {
                              // If the node doesn't have a modified color, reset to base color

                             node.style('background-color', '');
                            }
                          });
                        }
                      
                
                
                

                    

                function makeTagsEditable(element) {
                    const nodeId = currentOpenNodeId;
                    const node = cy.$id(nodeId);
                    const tags = node.data('tags') ? node.data('tags').split(', ') : [];
                
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = tags.join(', ');
                    input.onblur = function () {
                        const newTags = input.value.split(', ');
                        node.data('tags', newTags.join(', '));
                        element.innerHTML = `<strong>Tags:</strong> ${newTags.join(', ')}`;
                        updateDropdownOptions();
                    };
                
                    element.innerHTML = '';
                    element.appendChild(input);
                    input.focus();
                }

                function makeCommentsEditable(element) {
                    const nodeId = currentOpenNodeId;
                    const node = cy.$id(nodeId);
                    const comments = node.data('comment') || '';
                
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = comments;
                    input.onblur = function () {
                        const newComments = input.value;
                        node.data('comment', newComments);
                        element.innerHTML = `<strong>Comments:</strong> ${newComments}`;
                    };
                
                    element.innerHTML = '';
                    element.appendChild(input);
                    input.focus();
                } 
                
                function makeTitleEditable(element) {
                    const nodeId = currentOpenNodeId;
                    const node = cy.$id(nodeId);
                    const comments = node.data('title') || '';
                
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = comments;
                    input.onblur = function () {
                        const newTitle = input.value;
                        node.data('title', newTitle);
                        element.innerHTML = `${newTitle}`;
                    };
                
                    element.innerHTML = '';
                    element.appendChild(input);
                    input.focus();
                }

                function makeReferencesEditable(element) {
                    const nodeId = currentOpenNodeId;
                    const node = cy.$id(nodeId);
                    const references = node.data('references') ? node.data('references').split(', ') : [];
                
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = references.join(', ');
                    input.onblur = function () {
                        const newReferences = input.value.split(', ');
                        node.data('references', newReferences.join(', '));
                        element.innerHTML = `<strong>References:</strong> ${newReferences.join(', ')}`;
                    };
                
                    element.innerHTML = '';
                    element.appendChild(input);
                    input.focus();
                }

                function updateDropdownOptions() {
                    const select = document.getElementById('tagSelect');
                    select.innerHTML = '';
                
                    const uniqueTags = new Set();
                    cy.nodes().forEach(function (node) {
                        const nodeTags = node.data('tags') ? node.data('tags').split(', ') : [];
                        nodeTags.forEach(tag => uniqueTags.add(tag));
                    });
                
                    const tagsArray = Array.from(uniqueTags);
                    tagsArray.forEach(tag => {
                        let option = document.createElement('option');
                        option.value = tag;
                        option.text = tag;
                        select.appendChild(option);
                
                        // If the tag doesn't have a color yet, assign it one
                        if (!tagColors[tag]) {
                            if (colorIndex < 6) {
                                tagColors[tag] = colorPalette[colorIndex];
                            } else {
                                // Assign a random desaturated color for each tag
                                
                                tagColors[tag] = getRandomHexColor();
                            }
                            colorIndex++;
                        }
                    });          
                }

                const nodes = cy.nodes();
                
                // Get the unique attributes from all nodes
                let nodeAttributes = [];
                nodes.forEach(node => {
                    nodeAttributes = [...nodeAttributes, ...Object.keys(node.data())];
                });
                nodeAttributes = [...new Set(nodeAttributes)]; // Remove duplicates

                 
                // Get the select element
                const attributeSelector = $('#attributeSelector');

                document.getElementById('cy').style.display = "none";

                // Initialize Select2 for the attributeSelector dropdown
                attributeSelector.select2({
                    placeholder: 'Select attributes',
                    allowClear: true,
                    closeOnSelect: false
                });

      

                

                // Populate the dropdown with options
                nodeAttributes.forEach(attribute => {
                    const isSelected = ['id','Sanskrit_Text', 'Translation_Bryant'].includes(attribute);
                    const option = new Option(attribute, attribute, isSelected, isSelected);
                    attributeSelector.append(option);
                });

                // Add the label function inside the style array
                cy.style().selector('node').style({
                    'label': function(ele) {
                        // Get the selected attributes
                        const selectedAttributes = $('#attributeSelector').select2('data').map(option => option.id);
                        // Build the label using the selected attributes
                        let label = '\n\n\n\n\n\n';
                        selectedAttributes.forEach(attribute => {
                            if (ele.data(attribute)) {
                                label += ele.data(attribute) + '\n\n';
                            }
                        });
                        return label;
                    },
                    // Your other styles here
                });
                
                                
             // Add nodeHtmlLabel for custom HTML labels
                cy.nodeHtmlLabel([{
                    query: 'node[title]',
                    valign: 'top', // Align to the top
                    halign: 'center',
                    valignBox: 'center',
                    halignBox: 'center',
                    tpl: function (data) {
                        const title = data.title; // Assuming 'title' is the attribute you want to display

                        // Display only the title in bold, centered, and on the upper part of the node
                        return '<div style="font-family: Palatino, Palatino Linotype, serif; font-size: 12px; font-weight: bold; text-align: center; max-width: 200px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;">' + title + '</div>';
                    }
                }]);



                // Update the Cytoscape styles whenever the selected options change
                $('#attributeSelector').on('change', function() {
                    cy.style().update(); // This will force Cytoscape to reapply the styles
                });
                
                // Get the select element for the display
                const displaySelector = $('#displaySelector');
                
                
                // Populate the dropdown with options
                nodeAttributes.forEach(attribute => {
                    // Exclude 'tags', 'references', and 'comment' fields
                    if (!['tags', 'references', 'comment'].includes(attribute)) {
                        const isSelected = ['Sanskrit_Text', 'Translation_Bryant', 'Word_for_Word_Analysis', 'Vyasa_sanskrit'].includes(attribute);
                        const option = new Option(attribute, attribute, isSelected, isSelected);
                        displaySelector.append(option);
                    }
                });

                // Initialize Select2 for the attributeSelector dropdown
                displaySelector.select2({
                    placeholder: 'Select attributes',
                    allowClear: true,
                    closeOnSelect: false
                }).on('select2:opening', function(e) {
                    // Stop the mousedown event from propagating to Cytoscape
                    e.stopPropagation();
                });

                 // Store the currently selected node
                 let selectedNode = null;
                 
                 
                 
                
                 
                 
                 
       
                 
                 // Assuming you have an input element with the ID 'color-picker-specificnode'
                  const colorPickerSpecificNode = document.getElementById('color-picker-specificnode');

                  // Update node color when the color picker changes
                  colorPickerSpecificNode.addEventListener('input', function() {
                    const selectedNode = cy.$(':selected'); // Get the currently selected node

                    if (selectedNode.length > 0) {
                      const color = colorPickerSpecificNode.value;

                      // Change the background color of the selected node
                      selectedNode.style('background-color', color);
                      
                      
                      // Update the modified color for the selected node
                      modifiedNodeColors.set(selectedNode.id(), color);
                    }
                    
                  });
                  
                  
                  // Update selectedNode whenever a node is selected
                 cy.on('select', 'node', function(event) {
                     selectedNode = event.target;
                     
                     const nodeBackgroundColorRGB = selectedNode.style('background-color');
                     // Convert RGB to hex
                     const nodeBackgroundColorHex = rgbToHex(nodeBackgroundColorRGB);
                     // Update the color picker value
                     colorPickerSpecificNode.value = nodeBackgroundColorHex;
                     
                     selectedNode.addClass('spotted');
                     updateDetailsWindow();
                     const nodeBackgroundColor = selectedNode.style('background-color');
                     


                                    // Get the background color in RGB format
                    
                });
                
                const modifiedNodeColors = new Map();

                // RGB to Hex conversion function
                function rgbToHex(rgb) {
                    const rgbArray = rgb.match(/\d+/g).map(Number);
                    return '#' + rgbArray.map(value => {
                        const hex = value.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');
                }

                 
                 
                 
                 // Clear selectedNode whenever a node is unselected
                 cy.on('unselect', 'node', function() {
                      
                    selectedNode.removeClass('spotted');
                
                    selectedNode = null;
                    updateDetailsWindow();
                     

                 });
                 
                 // Update the details window whenever the selected options change
                 $('#displaySelector').on('change', updateDetailsWindow);
                 
                 function updateDetailsWindow() {
                     if (selectedNode) {
                         // Get the selected attributes
                         const selectedAttributes = $('#displaySelector').select2('data').map(option => option.id);
                         
                         // Build the details content using the selected attributes
                       let detailsContent = '<h2 class="w-full" style="font-weight: bold !important; text-align: center; margin-bottom: 2em;">Sutra ' + selectedNode.id() + '</h2>';               selectedAttributes.forEach(attribute => {
                            if (selectedNode.data(attribute)) {
                                detailsContent += `<p class="w-full "><strong>${attribute}:</strong> ${selectedNode.data(attribute)}</p>`;
                            }
                        });
                        
                         document.getElementById('titleSection').innerHTML = `${selectedNode.data('title') || 'Title'}`;
 
                         // Update the details content
                         document.getElementById('details-content').innerHTML = detailsContent;
                         

                         // Update the editable content
                         document.getElementById('tagsSection').innerHTML = `<strong>Tags:</strong> ${selectedNode.data('tags') || ''}`;
                         document.getElementById('referencesSection').innerHTML = `<strong>References:</strong> ${selectedNode.data('references') || ''}`;
                         document.getElementById('commentsSection').innerHTML = `<strong>Comments:</strong> ${selectedNode.data('comment') || ''}`;
                     } 
                 }

                 function updateDetailsID(nodeId) {
                    // Get the node from the Cytoscape graph
                    var selectedNode = cy.getElementById(nodeId);
                
                    if (selectedNode.length > 0) {
                        // Get the selected attributes
                        const selectedAttributes = $('#displaySelector').select2('data').map(option => option.id);
                
                        // Build the details content using the selected attributes
                        let detailsContent = '<h2>Aphorism Details</h2>';
                        selectedAttributes.forEach(attribute => {
                            if (selectedNode.data(attribute)) {
                                detailsContent += `<p><strong>${attribute}:</strong> ${selectedNode.data(attribute)}</p>`;
                            }
                        });
                        
                        document.getElementById('titleSection').innerHTML = `${selectedNode.data('title') || ''}`;
                
                        // Update the details content
                        document.getElementById('details-content').innerHTML = detailsContent;
                
                        // Update the editable content
                        
                        document.getElementById('tagsSection').innerHTML = `<strong>Tags:</strong> ${selectedNode.data('tags') || ''}`;
                        document.getElementById('referencesSection').innerHTML = `<strong>References:</strong> ${selectedNode.data('references') || ''}`;
                        document.getElementById('commentsSection').innerHTML = `<strong>Comments:</strong> ${selectedNode.data('comment') || ''}`;
                    } else {
                        // Clear the details content if no node is selected
                        
                        
                        document.getElementById('details-content').innerHTML = '';
                        document.getElementById('tagsSection').innerHTML = '<strong>Tags:</strong>';
                        document.getElementById('referencesSection').innerHTML = '<strong>References:</strong>';
                        document.getElementById('commentsSection').innerHTML = '<strong>Comments:</strong>';
                    }
                }
                
                

                
                
                
                


                cy.on('tap', 'node', function (event) {
                    const node = event.target;
                    openLeftSidebar(node);
                });   
            })
            .catch(error => console.error('Error:', error));
        });



        document.getElementById('sidebarToggle').addEventListener('click', function() {
            var sidebar = document.getElementById('sidebar');
            if (sidebar.style.transform === "translateX(100%)") {
              sidebar.style.transform = "translateX(0)";  
              sidebar.style.boxShadow = "-1px 0px 3px 0px rgba(0,0,0,0.3)";        
            } else {
              sidebar.style.transform = "translateX(100%)";
            }
          });
          
          function toggleContent() {
            var cy = document.getElementById('cy');
            var textContainer = document.getElementById('textContainer');
            var myDiv = document.getElementById('myDiv');
            
            document.body.style.backgroundColor = "#fdfdfd";
            
            cy.style.display = "block";
            cy.style.opacity = "0";
            myDiv.style.opacity = "0.75";
            
            // After a delay, change the opacity of the background
            setTimeout(function() {
                myDiv.style.opacity = "0.75";
                cy.style.opacity = "0.15";
            }, 500);  // Delay in milliseconds

            // After a delay, change the opacity of the background
            setTimeout(function() {
                myDiv.style.opacity = "0.60";
                cy.style.opacity = "0.30";
            }, 1000);  // Delay in milliseconds
            
            // After a delay, change the opacity of the background
            setTimeout(function() {
                myDiv.style.opacity = "0.50";
                cy.style.opacity = "0.45";
            }, 1500);  // Delay in milliseconds
            // After a delay, change the opacity of the background
            setTimeout(function() {
                myDiv.style.opacity = "0.25";
                cy.style.opacity = "0.65";
                wonderHeader.style.backgroundColor = "#fbfbfb"
            }, 2000);  // Delay in milliseconds
            
            // After a longer delay, remove the background
            setTimeout(function() {       
                myDiv.style.backgroundImage = "none";
                myDiv.style.opacity = "1";
                textContainer.style.display = "none";
                cy.style.opacity = "1";

                var divideLine = document.getElementById('divideLine');
                // Remove the old class
                divideLine.classList.remove('inset-x-1/4');
                divideLine.classList.remove('bg-gray-700');

                // Add the new class
                divideLine.classList.add('inset-x-0');
                divideLine.classList.add('bg-gray-500');


                var rightSidebar = document.getElementById('sidebar');
                rightSidebar.style.transform = "translateX(0)";  
                rightSidebar.style.boxShadow = "-1px 0px 3px 0px rgba(0,0,0,0.3)";       
                

                var leftSidebar = document.getElementById('leftSidebar');
                leftSidebar.style.transform = "translateX(0)";
                leftSidebar.style.boxShadow = "1px 0px 3px 0px rgba(0,0,0,0.3)";
                
            }, 2500);  // Delay in milliseconds
        }

         interact('#leftSidebar')
            .resizable({
                edges: { left: true, right: true, bottom: false, top: false },
                modifiers: [
                interact.modifiers.restrictEdges({
                    outer: 'parent',
                }),
                interact.modifiers.restrictSize({
                    min: { width: 100, height: 50 },
                }),
                ],
                inertia: true,
            })
            .on('resizemove', function (event) {
                var target = event.target;
                var x = parseFloat(target.getAttribute('data-x')) || 0;

                target.style.width = event.rect.width + 'px';
                target.style.height = event.rect.height + 'px';
                x += event.deltaRect.left;
                target.style.transform = 'translate(' + x + 'px)';
                target.setAttribute('data-x', x);
            });

                
          interact('.resizable-section')
            .resizable({
              edges: {  top: true, bottom: true },

              onmove: function (event) {
                var target = event.target;
                
                var height = parseFloat(target.getAttribute('data-height')) || target.offsetHeight;


                height += event.deltaRect.height;


                target.style.height = height + 'px';


                target.setAttribute('data-height', height);
              },
            });
          

                
        
 
        
    
    
    </script>
</body>
</html> 
